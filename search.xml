<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>好用的工具</title>
      <link href="/2025/01/10/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/01/10/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p><a href="https://www.efc123.com/shop">EFCloud</a> —— 跑路了，八嘎</p><p><a href="https://一元机场.ink/">一元机场</a> —— 非常稳定，几年了还在，就是节点很不稳定</p><h2 id="ICON"><a href="#ICON" class="headerlink" title="ICON"></a>ICON</h2><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></p><p><a href="https://fontawesome.com/">FONT AWESOME</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记 - Android</title>
      <link href="/2025/01/10/%E7%AC%94%E8%AE%B0-Android/"/>
      <url>/2025/01/10/%E7%AC%94%E8%AE%B0-Android/</url>
      
        <content type="html"><![CDATA[<h2 id="一些常识"><a href="#一些常识" class="headerlink" title="一些常识"></a>一些常识</h2><p><strong>STR</strong>（Suspend to RAM）待机是一种电源管理技术，用于在设备（如计算机、智能手机或平板电脑）不使用时节省电能。在这种模式下，系统的状态被保存在RAM（随机存取存储器）中，而大部分硬件组件被置于低功耗状态。以下是关于STR待机的一些详细信息：</p><h3 id="STR待机的特点"><a href="#STR待机的特点" class="headerlink" title="STR待机的特点"></a>STR待机的特点</h3><ol><li><strong>快速恢复</strong>：<ul><li>当设备从STR待机状态唤醒时，系统状态从RAM中恢复，因此恢复速度非常快，通常只需几秒钟。</li></ul></li><li><strong>低功耗</strong>：<ul><li>在STR待机模式下，设备的大部分硬件组件被关闭或置于低功耗状态，从而显著降低功耗。这使得设备在待机状态下可以保持较长时间而不消耗太多电池电量。</li></ul></li><li><strong>状态保存</strong>：<ul><li>系统的当前状态（包括运行的应用程序、打开的文件等）被保存在RAM中。这意味着当设备从待机状态唤醒时，用户可以立即继续之前的工作，而无需重新启动系统或应用程序。</li></ul></li></ol><h3 id="STR待机的工作原理"><a href="#STR待机的工作原理" class="headerlink" title="STR待机的工作原理"></a>STR待机的工作原理</h3><ol><li><strong>进入待机</strong>：<ul><li>当用户触发待机操作（例如，通过关闭屏幕或按下电源按钮）时，系统开始将当前状态保存到RAM中。</li><li>系统关闭或降低大部分硬件组件的电源，包括CPU、GPU、硬盘等，但保持RAM的电源供应，以保存系统状态。</li></ul></li><li><strong>唤醒设备</strong>：<ul><li>当用户通过特定的操作（例如，按下电源按钮或打开屏幕）唤醒设备时，系统从RAM中恢复保存的状态。</li><li>硬件组件被重新激活，系统恢复到待机前的状态，用户可以立即继续使用设备。</li></ul></li></ol><h3 id="STR待机与休眠模式的区别"><a href="#STR待机与休眠模式的区别" class="headerlink" title="STR待机与休眠模式的区别"></a>STR待机与休眠模式的区别</h3><ul><li><p>休眠模式（Suspend to Disk）</p><p>：</p><ul><li>在休眠模式下，系统的状态被保存到硬盘上，而不是RAM中。这意味着即使在完全断电的情况下，系统状态也不会丢失。</li><li>休眠模式的恢复速度比STR待机慢，因为需要从硬盘读取系统状态，通常需要几十秒到几分钟不等。</li><li>休眠模式的功耗更低，因为设备在休眠状态下可以完全断电，适合长时间不使用设备的情况。</li></ul></li></ul><h3 id="示例：在Android设备中实现STR待机"><a href="#示例：在Android设备中实现STR待机" class="headerlink" title="示例：在Android设备中实现STR待机"></a>示例：在Android设备中实现STR待机</h3><p>在Android设备中，STR待机通常通过系统设置中的电源管理选项实现。以下是一个简单的示例，展示如何在Android应用中请求设备进入待机状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.os.PowerManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerManagerHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goToSleep</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">PowerManager</span> <span class="variable">powerManager</span> <span class="operator">=</span> (PowerManager) context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (powerManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            powerManager.goToSleep(PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>权限</strong>：请求设备进入待机状态可能需要特定的权限，具体取决于设备的制造商和Android版本。</li><li><strong>用户交互</strong>：通常，用户通过物理按钮（如电源按钮）触发待机操作，而不是通过应用直接请求待机。</li><li><strong>系统兼容性</strong>：不同的设备和操作系统版本可能对电源管理有不同的实现和限制，需要进行充分的测试以确保兼容性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复盘</title>
      <link href="/2025/01/07/%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/01/07/%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>首先选品根据用户需求出发，当时正值圣诞节，可以做一些圣诞素材之类的品，蕾哥给我推荐了<strong>圣诞代码</strong>这个品</p><p><img src="https://blog-vanh.oss-cn-hangzhou.aliyuncs.com/image/20250107201638156.png" alt="同行"></p><p>淘宝同款搜了一下，做的人并不多，而且有其他店铺的品已经有40+的销量了，当时距离圣诞还有两个多星期，已经有很不错的成绩了</p><p>所以这个品肯定是有搞头的，于是网上找了些开源的圣诞树代码上架了</p><h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><p>既然知道品有搞头，且已经上架了相关品，那么得让你的品让人能看到，于是需要进行常规的三轮补单</p><p>补完单已经开始有访客和客户了，这个时候客户还不多，做的一些客制化都尽量满足，所以也是收到不少好评，相当于免费给我做了精补</p><p>这一步是至关重要的，增加商品权重，后续自己也针对性的做了精补，</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>针对品的优化主要在于搜索词和商品主图，准确来说，搜索词和前面的精补是同时进行的，根据<strong>圣诞代码</strong>这个大类搜到很多品，提取这些品的关键词，</p><p>做进一步的组合，成为我们的新商品名，让客户尽可能地容易的搜到我们的品；针对商品主图的优化，尽可能把代码运行后最精彩的部分截图&#x2F;录屏（</p><p>非代码品的话则截取关键目录），达到精准定位客户的目的，也是为了减少客户咨询内容&#x2F;次数，省时省力。</p><p>优化如果还有一步的话则在价格调整，如果销量明显上升后，适量提高价格，保证这个品的利润最大化，毕竟就这一波机会。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实说起来也简单，就几步 <strong>挖掘客户需求</strong> ——&gt; <strong>选品</strong> ——&gt; 补单 ——&gt; 精补&#x2F;优化</p><p>我另一款爆品，也是同样的的步骤，不过当时是访客量骤增但是没有销量，所以只是针对性做了精补，然后就一飞冲天了，目前销量600+了。</p>]]></content>
      
      
      <categories>
          
          <category> 副业 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 店铺 </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优秀文章 - Android</title>
      <link href="/2025/01/06/%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-Android/"/>
      <url>/2025/01/06/%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-Android/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/386bbb5fa29a">Android卡顿掉帧问题分析之原理篇</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 - Android</title>
      <link href="/2025/01/06/%E9%9D%A2%E8%AF%95%E9%A2%98-Android/"/>
      <url>/2025/01/06/%E9%9D%A2%E8%AF%95%E9%A2%98-Android/</url>
      
        <content type="html"><![CDATA[<p>APP进程启动流程<br>Activity finish流程<br>WMS addWindow的主要工作<br>介绍一下Task<br>说一下窗口容器树结构<br>WindowToken和WindowState是什么关系<br>Activity界面最终显示出来的整体流程<br>内存增长怎么分析<br>kotlin 协程和线程有什么区别<br>Framework调试怎么加断点</p><p>A是C端，B是S端，<br>问 如何保证 A 知道B 是否存活，，B如何知道 A存活,<br>如果 A死了，B该怎么办？<br>B 死了 A该怎么办？</p><p>‘## 问原理<br>*什么是 Android Binder?<br>Android Binder 是如何实现进程间通信的?<br>Android 为什么采用 Binder 作为主要的的 IPC 机制?<br>Binder 是如何实现仅通过一次拷贝将数据从 A 进程传递给 B 进程的?<br>Binder 的优势是什么?<br>这些都是问 Binder 的基本原理，回答都大同小异。对于应用层开发，99%止步于此，再问就不礼貌了。<br>如果是应聘 Framework 岗位，可能还需要熟悉下面的问题。</p><h2 id="问流程"><a href="#问流程" class="headerlink" title="问流程"></a>问流程</h2><p>说一下进程从ServiceManager获取服务的流程Binder 是如何找到目标服务并唤醒目标进程&#x2F;线程的Android Binder 中的 Proxy 和 Stub 是什么<br>应用该如何获取和添加 Binder 服务?<br>AIDL 是什么?如何使用的?<br>Android Binder 中有哪些组件?工作的流程是什么?<br>无论怎么问，只要把之前讲的 Native 和 Java 层示例程序的源码分析掌握，就可以以不变应万变</p><h2 id="问细节"><a href="#问细节" class="headerlink" title="问细节"></a>问细节</h2><p>了解 mmap 的原理吗?<br>使用 Binder 传输数据的最大限制是多少，被占满后会导致什么问题?<br>Intent 传递大数据限制?<br>binder_proc 结构体中有两个 binder_ref 红黑树，它们的作用是什么?<br>Android APP 进程天生支持Binder通信的原理是什么?<br>AIDL 中的 in out inout oneway 这些关键字的作用是什么?<br>Intent 传递大数据限制?<br>Binder 服务在调用期间抛出了 RuntimeException 异常，服务端会 crash 么?<br>客户端调用 Binder 接口后抛出的 DeadobjectException 是什么意思?<br>Binder 驱动加载过程中有哪些重要的步骤?<br>Binder 的死亡通知机制的作用是什么，它是如何实现的?<br>bindservice 所绑定的”服务概念和 Binder 中的服务 Server 有什么区别?<br>writestrongBinder与readstrongBinder的作用和原理?<br>每个进程最多存在多少个 Binder 线程，这些线程都被占满后会导致什么问题?<br>Binder 驱动什么时候释放缓冲区的内存?<br>为什么使用广播传输 2MB的Bitmap会抛异常，而使用AIDL生成的 Binder 接口传输 Bitmap 就<br>不会抛异常呢?<br>应用进程为什么支持 Binder 通信，直接可以使用四大组件呢?<br>四大组件中常见的 2 个 Binder 服务是?<br>Binder 都有什么主要的协议?Binder 协议中BC 与BR 开头的协议都有什么区别?*A 是 c 端，B 是s 端，问 如何保证 A 知道 8 是否存活，，B 如何知道 A 存活，如果 A 死了，B 该怎么办?B 死了 A 该怎么办?<br>细节就比较见功底了，需要我们从应用到内核层，对 Binder 有非常全面的了解。</p><p>1.invalidate和requestlayout对后续绘制渲染有什么不同?<br>2.为什么View刚被加载时想获取其的宽高,需要view.post(Runnalbe)中获取?3.黄油计划提出的Vsync和三缓冲机制为什可以大大改善Android的交互和流畅度体验?<br>4. Vsync信号是谁发出的?需要App主动请求吗?界面没有变化是否会有Vsync信号?<br>App是否响应Vsync信号取决于什么?<br>5.调用android绘制三部曲(measure、layout和draw)的performTraversals是怎么触发的?<br>6.Android的同步屏障和异步消息是什么，它们如何在渲染机制中发挥作用的?7.SurfaceView°&#x2F;TextureView渲染视频时频繁的刷新界面，为什么U!界面不卡顿?8.android 5.0引入的硬件加速RenderThread是如何提升渲染效率的?指令归类重排序是什么?<br>9.动画可以在RenderThread上执行吗<br>10.使用OpengGLES渲染时进行eglSwapBuffer切换前后台Buffer依赖Vsync信号吗?11.App进程将views树构建为DisplayList给到GPU进行渲染到Surface 上作为BufferQueue°的生产者，SurfaceFlinger是BufferQueue的消费者获取Surface转为layer进行不同layer的合成，那么App进程和SurfaceFlinger进程是如何通信的?12.VSYNC信号是通过什么方式传递?<br>13.整体上介绍下Android绘制渲染流程，App开发者熟悉渲染流程后对于日常开发有什<br>么帮助?</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技巧</title>
      <link href="/2024/12/21/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/12/21/%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="如何一次性删除所有以某关键词结尾的文件"><a href="#如何一次性删除所有以某关键词结尾的文件" class="headerlink" title="如何一次性删除所有以某关键词结尾的文件"></a>如何一次性删除所有以某关键词结尾的文件</h4><blockquote><p>其他类型删除以此类推</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &#x27;*.ko&#x27; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
